# TOOLBOX-PENTEST
Conception d'une toolbox de pentest en Python pour détecter et corriger les failles de sécurité. 


Les modules utilisés sont :

import tkinter as tk            ## créer des interfaces graphiques en Python. tk simplifie l'appel de la fonction tkinter.

from tkinter import scrolledtext, messagebox    ## scrolledtext permet d'ajouter une zone de texte avec une barre de défilement intégrée & messagebox affiche des boîtes de dialogue (messages d'alerte, d'erreur, de confirmation...)

from threading import Thread     ##
import socket      ##
import os     ##
import wmi      ##
from tkinter import ttk     ##
from tkinter import filedialog    ##
from reportlab.lib.pagesizes import letter   ##
from reportlab.pdfgen import canvas   ##
import subprocess   ##
from PIL import Image, ImageTk   ##
import time   ##
import os   ##
import hashlib   ##
import re   ##  
import subprocess   ##
from tkinter import filedialog, Tk   ##


                                      EXPLICATION DU CODE 1.scan_mustapha_seghdau
___________________________________________________________________________________________________________

Fonction main_window()

Cette fonction définit et configure la fenêtre principale de l'application.
------------------------------------------------------------------------------------------------------------
Fonctions internes à main_window()

scan(ip, scan_type) :

Effectue une analyse réseau en fonction du type d'analyse choisi (Simple, OS, Version, TCP, Scan + Vulnérabilité).
Utilise subprocess.run() pour exécuter des commandes nmap et capture la sortie.
-------------------------------------------------------------------------------------------------------------
generate_pdf(result) :

Génère un fichier PDF avec les résultats de l'analyse en utilisant reportlab.
Demande à l'utilisateur où enregistrer le fichier PDF.
--------------------------------------------------------------------------------------------------------------
action_scan() :

Récupère l'adresse IP et le type d'analyse sélectionné.
Appelle la fonction scan() et met à jour l'interface avec les résultats.
--------------------------------------------------------------------------------------------------------------
print_report() :

Appelle generate_pdf() pour créer un PDF des résultats de l'analyse.
--------------------------------------------------------------------------------------------------------------
reset_window() :

Réinitialise les champs de saisie et les résultats.
--------------------------------------------------------------------------------------------------------------
start_loading() et stop_loading() :

Gère l'affichage d'un message de chargement pendant les opérations longues.
Création de l'interface graphique
--------------------------------------------------------------------------------------------------------------
Fenêtre principale root :

Configuration de la fenêtre principale (title, background, transparency).
--------------------------------------------------------------------------------------------------------------
Cadre frame :

Un cadre pour organiser les widgets.
--------------------------------------------------------------------------------------------------------------
Étiquettes et champs de saisie :

ip_label et ip_entry pour l'adresse IP.
scan_type_label et scan_type_menu pour le type d'analyse.
--------------------------------------------------------------------------------------------------------------
Boutons :

scan_button pour lancer l'analyse.
--------------------------------------------------------------------------------------------------------------
reset_button pour réinitialiser les champs.
--------------------------------------------------------------------------------------------------------------
print_button pour imprimer le rapport en PDF.
--------------------------------------------------------------------------------------------------------------
result_label pour afficher les résultats de l'analyse.
--------------------------------------------------------------------------------------------------------------







CODE COMPLET AVEC COMMENTAIRE : 
____________________________________________________________________________________________________________________________________________________________
# Importation des modules nécessaires
import subprocess
import tkinter as tk
from tkinter import ttk, filedialog
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas

# Fonction principale de la fenêtre
def main_window():
    # Fonction pour exécuter le scan avec nmap
    def scan(ip, scan_type):
        start_loading()  # Démarrer l'animation de chargement
        try:
            # Exécuter différentes commandes nmap selon le type de scan sélectionné
            if scan_type == "Simple":
                result = subprocess.run(['nmap', ip], capture_output=True, text=True).stdout
            elif scan_type == "OS":
                result = subprocess.run(['nmap', '-O', ip], capture_output=True, text=True).stdout
            elif scan_type == "Version":
                result = subprocess.run(['nmap', '-sV', ip], capture_output=True, text=True).stdout
            elif scan_type == "TCP":
                result = subprocess.run(['nmap', '-sT', ip], capture_output=True, text=True).stdout
            elif scan_type == "Scan + Vulnérabilité":
                result = subprocess.run(['nmap', '--script', 'vuln', '--script-args', 'vulns.showall', ip], capture_output=True, text=True).stdout
            else:
                result = "Invalid scan type"  # Message pour un type de scan invalide
        except Exception as e:
            result = f"Error: {str(e)}"  # Capturer les erreurs éventuelles
        stop_loading()  # Arrêter l'animation de chargement
        return result  # Retourner le résultat du scan

    # Fonction pour générer un PDF avec le résultat du scan
    def generate_pdf(result):
        # Ouvrir une boîte de dialogue pour enregistrer le fichier PDF
        filename = filedialog.asksaveasfilename(defaultextension=".pdf", filetypes=[("PDF files", "*.pdf")])
        if filename:
            # Créer un document PDF
            c = canvas.Canvas(filename, pagesize=letter)
            c.drawString(100, 750, "Nmap Report")  # Titre du rapport
            c.drawString(100, 730, "-" * 50)  # Ligne de séparation
            c.drawString(100, 700, "Scan Result:")  # Sous-titre
            y = 680  # Position verticale initiale pour le texte
            # Ajouter chaque ligne du résultat du scan au PDF
            for line in result.split("\n"):
                c.drawString(100, y, line)
                y -= 15  # Déplacer la position verticale pour la ligne suivante
            c.save()  # Sauvegarder le PDF

    # Fonction pour lancer le scan
    def action_scan():
        ip_address = ip_entry.get()  # Récupérer l'adresse IP saisie
        selected_scan = scan_type_var.get()  # Récupérer le type de scan sélectionné
        result = scan(ip_address, selected_scan)  # Exécuter le scan
        result_text.set(result)  # Afficher le résultat

    # Fonction pour imprimer le rapport
    def print_report():
        generate_pdf(result_text.get())  # Générer un PDF avec le résultat

    # Fonction pour réinitialiser la fenêtre
    def reset_window():
        ip_entry.delete(0, tk.END)  # Effacer l'adresse IP saisie
        result_text.set("")  # Réinitialiser le texte du résultat
        scan_type_var.set("")  # Réinitialiser le type de scan sélectionné

    # Fonction pour démarrer l'animation de chargement
    def start_loading():
        loading_label.config(text="Loading...")  # Afficher le texte de chargement
        loading_progress.start()  # Démarrer la barre de progression

    # Fonction pour arrêter l'animation de chargement
    def stop_loading():
        loading_label.config(text="")  # Effacer le texte de chargement
        loading_progress.stop()  # Arrêter la barre de progression

    # Création de la fenêtre principale
    root = tk.Tk()
    root.title("Nmap Scanner")  # Titre de la fenêtre
    root.configure(bg='#1e1e1e')  # Configurer la couleur de fond
    root.attributes("-alpha", 0.95)  # Configurer la transparence de la fenêtre

    # Création du cadre principal
    frame = tk.Frame(root, bg='#1e1e1e')
    frame.pack(padx=20, pady=20)

    result_text = tk.StringVar()  # Variable pour stocker le texte du résultat
    scan_type_var = tk.StringVar()  # Variable pour stocker le type de scan sélectionné

    # Label et entrée pour l'adresse IP
    ip_label = tk.Label(frame, text="Enter IP Address:", bg='#1e1e1e', fg='#ffbb00', font=('Helvetica', 12, 'bold'))
    ip_label.grid(row=0, column=0, padx=(0, 20), pady=(0, 10))

    ip_entry = tk.Entry(frame, bg='#333333', fg='#ffffff', font=('Helvetica', 12))
    ip_entry.grid(row=0, column=1, padx=(0, 20), pady=(0, 10))

    # Label et menu pour le type de scan
    scan_type_label = tk.Label(frame, text="Select Scan Type:", bg='#1e1e1e', fg='#ffbb00', font=('Helvetica', 12, 'bold'))
    scan_type_label.grid(row=1, column=0, padx=(0, 20), pady=(0, 10))

    scan_type_options = ["Simple", "OS", "Version", "TCP", "Scan + Vulnérabilité"]
    scan_type_menu = tk.OptionMenu(frame, scan_type_var, *scan_type_options)
    scan_type_menu.config(bg='#333333', fg='#ffffff', font=('Helvetica', 12))
    scan_type_menu.grid(row=1, column=1, padx=(0, 20), pady=(0, 10))

    # Bouton pour lancer le scan
    scan_button = tk.Button(frame, text="Scan", command=action_scan, width=15, height=2, bg='#87ceeb', fg='#1e1e1e', font=('Helvetica', 12, 'bold'))
    scan_button.grid(row=2, column=0, columnspan=2, padx=(0, 20), pady=(0, 10))

    # Label pour afficher le résultat du scan
    result_label = tk.Label(frame, textvariable=result_text, fg="#00bfff", justify="left", anchor="w", wraplength=400, bg='#1e1e1e', font=('Helvetica', 10))
    result_label.grid(row=3, column=0, padx=(0, 20), pady=(0, 10), columnspan=2, sticky="w")

    # Bouton pour réinitialiser la fenêtre
    reset_button = tk.Button(frame, text="Reset", command=reset_window, width=15, height=2, bg='#87ceeb', fg='#1e1e1e', font=('Helvetica', 12, 'bold'))
    reset_button.grid(row=4, column=0, padx=(50, 20), pady=(0, 10))

    # Bouton pour imprimer le rapport
    print_button = tk.Button(frame, text="Print Report", command=print_report, width=15, height=2, bg='#87ceeb', fg='#1e1e1e', font=('Helvetica', 12, 'bold'))
    print_button.grid(row=4, column=1, padx=(0, 20), pady=(0, 10))

    # Barre de progression et label pour le chargement
    loading_progress = ttk.Progressbar(frame, mode='indeterminate', length=200)
    loading_label = tk.Label(frame, text="", bg='#1e1e1e', fg='#ffbb00', font=('Helvetica', 12, 'bold'))
    loading_label.grid(row=5, column=0, columnspan=2, pady=(10, 0))

    # Bouton pour retourner à l'accueil (fonction open_welcome_window non définie dans cet extrait)
    return_button = tk.Button(frame, text="Retour à l'accueil", command=open_welcome_window, width=15, height=2, bg='#87ceeb', fg='#1e1e1e', font=('Helvetica', 12, 'bold'))
    return_button.grid(row=6, column=0, columnspan=2, padx=(0, 20), pady=(0, 10))

    root.mainloop()  # Lancer la boucle principale de l'interface graphique

____________________________________________________________________________________________________________________________________________________________




