import tkinter as tk
from tkinter import scrolledtext, messagebox
from threading import Thread
import socket
import subprocess
import os
import wmi

# Fonction pour démarrer le serveur dans un thread
def start_server(ip_address, text_widget):
    # Définition du port
    port = 4445

    # Création du socket
    listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    listener.bind((ip_address, port))
    listener.listen(1)

    text_widget.insert(tk.END, f"[*] Écoute sur {ip_address}:{port}...\n")

    while True:
        # Attente de la connexion du client
        client, addr = listener.accept()
        text_widget.insert(tk.END, f"[*] Nouvelle connexion de {addr[0]}:{addr[1]}\n")

        while True:
            # Réception de la commande du client
            command = client.recv(1024).decode()

            if command.startswith("download "):
                # Téléchargement de fichier demandé par le client
                file_path = command.split(' ')[1]
                if os.path.exists(file_path):
                    with open(file_path, 'rb') as file:
                        client.sendall(file.read())
                else:
                    client.sendall(b"fichier introuvable")
            else:
                # Exécution de la commande sur le serveur
                result = subprocess.getoutput(command)
                client.sendall(result.encode())

                # Affichage du résultat dans le widget Text
                text_widget.insert(tk.END, f"Commande reçue : {command}\n")
                text_widget.insert(tk.END, f"Résultat :\n{result}\n\n")
                text_widget.see(tk.END)  # Faire défiler vers le bas pour afficher le dernier résultat

        # Fermeture de la connexion avec le client
        client.close()

    # Fermeture du socket d'écoute
    listener.close()

# Fonction pour démarrer le serveur dans un thread
def start_server_thread(ip_address, text_widget):
    server_thread = Thread(target=start_server, args=(ip_address, text_widget))
    server_thread.daemon = True
    server_thread.start()

# Fonction pour récupérer l'adresse IP saisie par l'utilisateur et démarrer le serveur
def start_server_handler():
    ip_address = ip_entry.get()
    if ip_address:
        start_server_thread(ip_address, text_output)
    else:
        text_output.insert(tk.END, "Veuillez saisir une adresse IP valide.\n")

# Fonction pour exécuter la commande ncat vers l'adresse IP saisie par l'utilisateur
def execute_ncat():
    ip_address = ip_entry.get()
    if ip_address:
        subprocess.Popen(["ncat", ip_address, "4445"])
    else:
        text_output.insert(tk.END, "Veuillez saisir une adresse IP valide pour utiliser ncat.\n")

# Fonction pour exécuter le code 2
def execute_code2():
    # Connexion à l'espace de noms WMI
    c = wmi.WMI()

    # Récupération des informations système
    system_info = c.Win32_OperatingSystem()[0]
    hostname = system_info.CSName
    osversion = system_info.Caption
    osarch = system_info.OSArchitecture
    uptime = system_info.LastBootUpTime
    timezone = system_info.CurrentTimeZone

    # Affichage des informations système
    text_output.insert(tk.END, f"Hostname: {hostname}\n")
    text_output.insert(tk.END, f"Operating System: {osversion}\n")
    text_output.insert(tk.END, f"Architecture: {osarch}\n")
    text_output.insert(tk.END, f"Uptime: {uptime}\n")
    text_output.insert(tk.END, f"Timezone: {timezone}\n\n")

    # Récupération des utilisateurs
    users = c.Win32_UserAccount()
    text_output.insert(tk.END, "Users:\n")
    for user in users:
        text_output.insert(tk.END, f"{user.Caption}\n")

    # Récupération des programmes installés
    programs = c.Win32_Product()
    text_output.insert(tk.END, "\nInstalled Programs:\n")
    for program in programs:
        text_output.insert(tk.END, f"{program.Name}\n")

    # Récupération des services
    services = c.Win32_Service()
    text_output.insert(tk.END, "\nServices:\n")
    for service in services:
        text_output.insert(tk.END, f"{service.Name} - {service.DisplayName}\n")

    # Récupération des informations sur les adaptateurs réseau avec une adresse IP commençant par '192.168.'
    text_output.insert(tk.END, "\nNetwork Adapters:\n")
    network_adapters = c.Win32_NetworkAdapterConfiguration(IPEnabled=True)
    for network_adapter in network_adapters:
        ip_addresses = [ip for ip in network_adapter.IPAddress if ip.startswith('192.168.')]
        if ip_addresses:
            text_output.insert(tk.END, f"Interface Name: {network_adapter.Description}\n")
            text_output.insert(tk.END, f"IP Address: {', '.join(ip_addresses)}\n")

    # Récupération des informations sur les disques
    text_output.insert(tk.END, "\nDrives:\n")
    drives = c.Win32_LogicalDisk()
    for drive in drives:
        text_output.insert(tk.END, f"Drive letter: {drive.DeviceID}\n")
        text_output.insert(tk.END, f"File system: {drive.FileSystem}\n")
        text_output.insert(tk.END, f"Free space: {round(drive.FreeSpace / (1024 ** 3), 2)} GB\n")
        text_output.insert(tk.END, f"Total space: {round(drive.Size / (1024 ** 3), 2)} GB\n")

    # Récupération des tâches planifiées
    text_output.insert(tk.END, "\nScheduled Tasks:\n")
    tasks = c.Win32_ScheduledJob()
    for task in tasks:
        text_output.insert(tk.END, f"Task Name: {task.Name}\n")
        text_output.insert(tk.END, f"Description: {task.Description}\n")
        text_output.insert(tk.END, f"Last Run Time: {task.LastRun}\n")
        text_output.insert(tk.END, f"Next Run Time: {task.NextRun}\n")
        text_output.insert(tk.END, f"Executed as: {task.Owner}\n")

        # Informations supplémentaires sur la tâche
        task_info = c.Win32_ScheduledJob.Get(ScheduledJobID=task.ScheduledJobID)
        text_output.insert(tk.END, f"Executable File: {task_info.Command}\n")
        text_output.insert(tk.END, f"Command Line Arguments: {task_info.Arguments}\n")

        text_output.insert(tk.END, "-----------------------------------\n")

# Création de la fenêtre principale
root = tk.Tk()
root.title("Serveur de commande")

# Champ de saisie pour l'adresse IP
ip_label = tk.Label(root, text="Adresse IP:")
ip_label.pack(pady=5)
ip_entry = tk.Entry(root)
ip_entry.pack(pady=5)

# Bouton pour démarrer le serveur
start_button = tk.Button(root, text="Démarrer le serveur", command=start_server_handler)
start_button.pack(pady=5)

# Bouton pour exécuter ncat
ncat_button = tk.Button(root, text="Exécuter ncat", command=execute_ncat)
ncat_button.pack(pady=5)

# Bouton pour exécuter le code 2
execute_button = tk.Button(root, text="Exécuter le code 2", command=execute_code2)
execute_button.pack(pady=5)

# Widget Text pour afficher les informations du terminal
text_output = scrolledtext.ScrolledText(root, wrap=tk.WORD, width=80, height=20)
text_output.pack(pady=10)

# Exécution de la boucle principale de l'interface graphique
root.mainloop()
